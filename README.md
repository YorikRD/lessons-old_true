# lessons
Занятие 1 (папка lesson1):
1. Типы данных 
2. Операторы 
3. Конструкции ветвления

Занятие 2 (папка lesson2):
1. Циклы
2. Массивы

Занятие 3 (папка lesson3):
1. Строки

Занятие 4 (папка lesson4):
1. Классы и объекты

Занятие 6 (папка com.damains.lesson6):
1. Абстактные классы
2. Интерфейсы

Занятие 8 (папка lesson8):
1. Object м его методы
2. Оператор final
3. Оператор static

Занятие 9 (папка lesson9):
1. Дата и время

Занятие 10 (папка lesson10):
1. Generic (обобщенное программирование)

Занятие 10 (папка lesson10):
1. Generic (обобщенное программирование)

Занятие 11 (папка lesson11):
1. enum (перечисления)
2. Коллекции

Занятие 12 (папка lesson12):
1. Map

Занятие 13 (папка lesson13):
1. Обработка исключений
2. Обрабатываемые исключение
3. Необрабатываемые исключение

Занятие 14 (папка lesson14):
1. IO - ввод вывод
2. IO - сериализация / десериализация

Занятие 15 (папка lesson15):
1. NIO ввод вывод

Занятие 16 (папка lesson16):
1. Лямбда выражения
2. Функциональныен интерфейсы

Занятие 17 (папка lesson17):
1. Stream API
2. Collectors

Занятие 18 (папка lesson18):
1. Garbage Collectors


### Домашнее задание 1 (к 20.10.19)
1. Найти наибольший общий делитель (НОД) двух чисел. Использовать цикл for
2. Написать программу перевода числа из 10 системы счисления в 2 систему счисления
3. Написать программу перевода числа из 10 системы счисления в 16 систему счисления
4. Дан массив целых чисел.
   Массив не отсортирован, числа могут повторяться.
   Необходимо найти в данном массиве такие два числа n и m,
   чтобы их сумма была равна 7.
   Например, 2 + 5 = 7, 6 + 1 = 7, -2 + 9 = 7.
   Задачу решить наиболее оптимальным способом

### Домашнее задание на СТРОКИ (необязательное)
1. Даны 2 слова, состоящие из четного числа букв. 
Получить слово состоящее из первой половины первого слова и второй половины второго слова.
2. Найдите самое длинное слово в предложении, при условии, что в предложении все слова разной длины.
3. Имеются две строки. Найти количество вхождений одной строки в другую.

### Домашнее задание на ЦИКЛЫ и МАССИВЫ (необязательное)
1. Сгенерировать 5 массивов из случайных чисел. 
Вывести массивы и сумму их элементов на экран. 
Найти массив с максимальной суммой элементов. 
Вывести его на экран еще раз. 
2. Вывести через на экран все числа от 1 до 100, с двумя исключениями. 
Для чисел, нацело делящихся на 3, нужно выводить ‘Three’, 
а для чисел, делящихся на 5 (но не на 3) – ‘Five’. 
Выводить  «ThreeFive» для всех чисел, которые делятся и на 3 и на 5.
3. Дан массив целых чисел и целое число. 
Удалите все вхождения этого числа из массива (пропусков быть не должно).
4. Заполните массив случайным числами и выведете максимальное, минимальное и среднее значение.
5. Определить дублированный элемент в массиве, в котором содержатся элементы типа int от 1 до 100, 
при условии, что в массиве дублируется только один элемент.

### Домашнее задание на КЛАССЫ и ОБЪЕКТЫ (необязательное):
1. Создать класс Cat с пятью конструкторами, через которые можно задать:
   1. имя
   2. имя, вес, возраст
   3. имя, возраст
   4. вес, цвет 
   5. вес, цвет, адрес владельца 
   
   Создать соответствующие сеттеры и геттеры.
   
   Создать метод, который выводит полную информацию о коте.
   
   Создать не менее 5 объектов (использовать разные конструкторы). 
   
2. Реализовать объектную модель: Яблоко, Дерево, Сад
   
   Яблоки должны иметь определяться:
   возрастом
   цветом
   размером
   флаг испорченности (true/false)
   флаг упавшего с дерева (true/false)
   
   Яблоки имею методы:
   упасть с дерева
   испортиться
   
   Яблоки добавляютя на деревья, деревья в сад.
   
   Реализовать метод getInfo в классе Garden, который выводит информацию о количестве деревьев и яблок.
   
3. Создать класс Warrior. 
   У воина должны быть указаны:
   имя, 
   возраст, 
   количество здоровья (тип int), 
   сила удара (тип int).
   
   Реализовать метод void fight(Warrior anotherWarrior) -  механизм битвы воинов:
   количество здоровья воина уменьшается на силу удара противника (anotherWarrior)
   
   Если у воина не осталось очков здоровья, выводить информацию, что он погиб в бою.

### Домашнее задание к LESSON4 (библиотека):
1. В классе Library реализовать метод String getInfo(Title bookTitle).
Метод должен возвращать строку в которой содержится следующая информация: 
автор, название, 
доступна ли для выдачи на дом,
есть ли в библиотеке на данный момент.
Если книга в библиотеке найдена не будет, метод возвращает строку "Такой книги в библиотеке нет"
2.  В классе Library реализовать метод Book takeHome(String title). Метод принимает на вход название книги, 
если книга найдена, возвращает экземпляр книги, если нет, возвращает null
3. В  методе void addBook(Book ...newBooks) класса Library должна быть 
выполнена проверка на случай переполнения массива с книгами.

### Домашнее задание к com.domain.LESSON6 (юниты):
1. Реализовать все необходимые проверки входящих данных в сеттерах
2. Написать реализацию метода атаки attack(Unit target) в классах:  Warrior, Knight, Doctor.
Не забываем, что для каждого юнита должна быть своя реализация атаки (логику придумать самостоятельно).

### Домашнее задание к LESSON9 (даты и время):
1. Есть три рабочие смены:
     1. с 7:00 до 15:00
     2. с 15:00 до 23:00
     3. с 23:00 до 7:00

Определить какая сейчас смена (относительно текущего времени)
2. Наши занятия закончатся 20 января 2020 года. Сколько занятий осталось,
если они проходят 3 раза в неделю (пн, ср, пт). Праздничные дни не учитывать.

Задания по пакету com.domain.LESSON6 (юниты):
3. В абстрактном классе BattleUnit создать статический метод,
возвращающий объекты боевых юнитов,
в зависимости от переданного типа юнита ("warrior", "knight", "doctor").
Характеристики задавать рандомно, имя задавать следующим образом:
тип юнита + рандомное число.
4. Конструктор класса King описан с модификатором private.
Создать в классе King  метод,
который будет служить альтернативой конструктору.

### Домашнее задание к LESSON12 (коллекции и мапы) по файлу resources/wp.txt:
1. Сосчитать частоту встречаемости слова или словосочетания в тексте (слово передаете аргументом).
2. Собрать все слова в группы по количеству букв: например, в одну группу попадут слова: [the, war, jar, get, met...], в другую [on, up, no, of...].
3. Вывести топ 10 самых частых слов и фраз.
4. Тоже, что и 2, но без артиклей, частиц и тп (без the, a, on, to...).
5. Вывести частоту встречаемости букв анг алфавита по этой книге. Вывести в процентах для каждой буквы

### Домашнее задание к LESSON13 (exception):
1. Написать калькулятор. 

Калькулятор считывает с консоли одно из выражений (n+m / n-m / nХm / n/m, где n и m - целые числа) или exit для завершения работы.
Калькулятор выводит результат вычисления в консоль, после чего ожидает ввода нового выражения или exit для завершения работы.

В случае если введенное выражение не совпадает с заданным шабломом, выбрасывает исключения:
    *отсутствуют n или m* - выбрасывать один тип исключения,
    *указан не тот оператор* - выбрасывать другое исключение,
    *в качестве оператора указан /, а второй операнд 0, либо n или m не целые числа* - выбрасывать третий тип исключения.

Необходимо написать свои классы исключений. Исключения должны быть проверяемыми (checked).
Метод исключений getMessage() необходимо переопределить (реализация на Ваше усмотрение).

2. Метод *static void throwException(Status status) throws JarException, FileNotFoundException, AccessDeniedException*
принимает на вход enum и выбрасывает следующие исключения в зависимости от значения status:
    1. если status FILE_NOT_FOUND, выбрасывает FileNotFoundException
    2. если status ACCESS_DENIED, выбрасывает AccessDeniedException
    3. если status JAR_ERROR, выбрасывает JarException.
    
При вызове метода throwException обработать исключения следующим образом:
*FileNotFoundException* - выводить в консоль стек трейс, 
*AccessDeniedException* - выводить в консоль сообщение исключения (метод getMessage()) и снова выбрасывать exception,
*JarException* - выводить в консоль стек трейс.

enum с необходимыми константами нужно создать.

3. Создать список исключений и заполнить его 9 различными runtime исключениями.
Например,

         try {
             int[] arr = new int[5];
             arr[7] = 12;
         } catch (Exception e) {
             exceptionsList.add(e);
         }

### Домашнее задание к LESSON14 (io):
1. Самостоятельно разобрать RandomAccessFile 
2. Разбить файл (информацию из одного файла записать в 2 разных файла). 
Склеить файл (информацию из нескольких файлов записать в один файл) 
3. Написать свои реализации InputStream и OutputStream, которые будут расширять FilterinputStream и FilterOutputStream,  
в переопределяемых методах (write и read) необходимо шифровать и дешифровать данные (использовать xor). 

### Домашнее задание к LESSON16 и LESSON17 (lambda + stream API):

Задания в папке Lesson17/tasks.
1. В папке Lesson17/tasks/task1/StudentTask.java
2. В папке Lesson17/tasks/task2/TransactionsTask.java
3. В папке Lesson17/tasks/task3/PupilTask.java

### Домашнее задание по многопоточности (№1):
##### Подсчет топ 100 слов (по частоте встречаемости) параллельно.

Количество потоков = Runtime.getRuntime().availableProcessors()

Каждый поток собирает результат в свой map, затем добавляет в общий map (не забывайте про синхронизацию).

Поток, который создавал другие потоки должен ожидать их завершения и выводить результат (топ 100 из общей мапы) в консоль.

### Домашнее задание по многопоточности (№2):

##### Client:
1. Читает сообщение от пользователя (из консоли), формирует объект сообщения и отправляет на сервер.
2. Получает входящие (от сервера) сообщения и выводит их в консоль.

Потоки, создаваемые на клиенте:
1. main поток (формирование и отправка сообщений)
2. reader поток (читает сообщения от сервера)

Подключение к серверу с использованием сокетов (tcp)
1. Socket socket = new Socket(String host, int port); - создание объекта + подключение к серверу
либо
2. Socket socket = new Socket(); - создание объекта
    1. SocketAddress serverAddr = new InetSocketAddress(String host, int port);
    2. socket.connect(serverAddr); - подключение к серверу


##### Server:
1. Получает сообщение от клиента.
2. Отправляет сообщение всем подключенным клиентам.
3. Сообщение не должно пересылаться отправителю.

Сокеты на стороне сервера:
1. ServerSocket serverSocket = new ServerSocket(port); ждет входящие подключения
2. Socket clientSocket = serverSocket.accept(); устанавливает соединение (воссоздавая клиентский сокет)

Для формирования уникального идентификатора соединения можно использовать следующие методы
(либо придумать свою систему идентификации):
1. clientSocket.getRemoteSocketAddress();
2. clientSocket.getPort();

Для хранения соединений и сообщений на сервере:
1. Потокобезопасный контейнер для хранения соединений (set или map)
2. LinkedBlockingDeque<Message> для хранения сообщений

Потоки, создаваемые на сервере:
1. writer поток (отправка сообщений клиентам)
2. reader потоки (читает сообщения от клиента) - на каждое соединение свой поток
3. Когда подключаетcя новый клиент необходимо сохранить соединение в set (или map) (когда клиент отсоединяется, удалить соединение из set (или map)).
4. Все полученные сообщения сохранять в блокирующей очереди - задача reader потока.
5. Рассылка сообщений по хранящимся в set (или map) соединениям - задача writer потока

##### Message implements Serializable
Обладает следующими характеристиками:
1. отправитель
2. текст сообщения
3. дата и время
4. можно добавть дополнительные свойства (для идентификации отправителя)
